<!DOCTYPE html>
<html>

<head>
    <title>古籍文献3D交互词云</title>
    <script src="./js/three.min.js"></script>
    <style>
        html {
            height: 100%;
            background: url('./img/界面背景.jpg') no-repeat center center fixed;
            background-size: cover;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Microsoft Yahei', sans-serif;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #2c5f2d;
            font-size: 20px;
            z-index: 200;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        #tooltip {
            position: absolute;
            background: rgba(44, 95, 45, 0.95);
            color: white;
            padding: 20px;
            border-radius: 8px;
            pointer-events: none;
            display: none;
            max-width: 320px;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            line-height: 1.6;
            z-index: 100;
        }

        .close-btn {
            position: absolute;
            right: 10px;
            top: 10px;
            cursor: pointer;
            color: #fff;
            font-size: 20px;
            transition: 0.3s;
            pointer-events: auto;
        }

        .close-btn:hover {
            color: #ffeb3b;
        }

        #tooltip h3 {
            margin: 0 0 15px 0;
            color: #ffeb3b;
        }

        .nav-button {
            position: fixed;
            top: 20px;
            right: 30px;
            padding: 12px 24px;
            background: rgba(44, 95, 45, 0.9);
            /* 与现有配色协调的深绿色 */
            color: #fff;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Microsoft Yahei';
            font-size: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            z-index: 150;
            backdrop-filter: blur(4px);
        }

        .nav-button:hover {
            background: rgba(67, 133, 68, 0.95);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        }

        #tooltip {
            /* 增加字体平滑 */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* 为Canvas容器增加锐化滤镜 */
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }
    </style>
</head>

<body>
    <button id="homeBtn" class="nav-button">返回主界面</button>
    <div id="loading">正在加载古籍文献数据...</div>
    <div id="tooltip">
        <span class="close-btn" onclick="closeTooltip(event)">×</span>
        <div id="tooltip-content"></div>
    </div>

    <script>
        const bookDetails = {
            // 原有10本
            '《齐民要术》': { author: '贾思勰', era: '北魏', desc: '中国现存最早最完整的农业百科全书，系统总结了6世纪前黄河中下游地区的农牧业生产经验' },
            '《农政全书》': { author: '徐光启', era: '明代', desc: '集古代农业科学之大成，包含农本、田制、农事、水利、农器等12个门类' },
            '《吕氏春秋·上农四篇》': { author: '吕不韦', era: '战国', desc: '包含《上农》《任地》《辨土》《审时》四篇，论述重农政策和耕作技术' },
            '《授时通考》': { author: '鄂尔泰', era: '清代', desc: '清代官修大型农书，汇集历代农事经验与天文历法知识' },
            '《四民月令》': { author: '崔寔', era: '东汉', desc: '反映汉代农业生产和家庭经济运作的月令体农书' },
            '《氾胜之书》': { author: '氾胜之', era: '西汉', desc: '现存最早农学专著，总结黄河流域农业生产经验，提出"趋时、和土、务粪泽"原则' },
            '《王祯农书》': { author: '王祯', era: '元代', desc: '兼论南北农业技术，首创《农器图谱》系统记录农具' },
            '《群芳谱》及《广群芳谱》': { author: '王象晋/汪灏', era: '明/清', desc: '植物学专著，记载各类植物的栽培利用方法' },
            '《月令七十二候集解》': { author: '吴澄', era: '元代', desc: '系统解释二十四节气七十二候的农时历书' },
            '《夏小正》': { author: '佚名', era: '先秦', desc: '中国现存最早记载物候变化的历书，反映夏代农耕文化' },

            // 新增非重复10本
            '《月令广义》': { author: '冯应京', era: '明代', desc: '月令类书，系统整理节气，立春习俗与农事记载丰富' },
            '《陈旉农书》': { author: '陈旉', era: '宋代', desc: '南方农事指南，强调天时，立春前后耕作建议明确' },
            '《农桑辑要》': { author: '司农司', era: '元代', desc: '官方农书，引《齐民要术》等，立春农事操作多次出现' },
            '《天工开物》': { author: '宋应星', era: '明代', desc: '虽偏技术，但农业部分涉及节气，如立春后作物管理' },
            '《岁时广记》': { author: '陈元靓', era: '宋代', desc: '节气与民俗记录，立春习俗（鞭春牛、祭祀）详述' },
            '《淮南子·时则训》': { author: '刘安', era: '西汉', desc: '西汉月令文献，立春物候与政令记载' },
            '《礼记·月令》': { author: '戴圣', era: '西汉', desc: '经典月令文本，立春礼仪与农事安排影响后世农书' },
            '《沈氏农书》': { author: '沈氏', era: '明代', desc: '明末江南农书，立春前后田间管理细则' },
            '《三农纪》': { author: '张宗法', era: '清代', desc: '综合性农书，节气与种植结合紧密' },
            '《农桑衣食撮要》': { author: '鲁明善', era: '元代', desc: '月令体农书，按月记载农事，立春条目明确' },
            '《田家五行》': {
                author: '娄元礼',
                era: '元代',
                desc: '气象农书，记载立春物候与农事占验，包含多首立春农谚'
            },
            '《农候杂占》': {
                author: '梁章钜',
                era: '明代',
                desc: '农事占候专著，卷三系统分析立春节气与耕作时序关系'
            },
            '《农丹》': {
                author: '张标',
                era: '清代',
                desc: '引《齐民要术》立春耕田法，提出地气理论指导春耕'
            },
            '《知本提纲·农则》': {
                author: '杨屾',
                era: '清代',
                desc: '记载关中地区立春"打春"仪式与农事启动规范'
            },
            '《农圃便览》': {
                author: '丁宜曾',
                era: '清代',
                desc: '山东农事指南，详述立春后不同土质耕作要领'
            },
            '《马首农言》': {
                author: '祁寯藻',
                era: '清代',
                desc: '山西农书，记录立春烧荒整地法与配套农谚'
            },
            '《营田辑要》': {
                author: '黄辅辰',
                era: '清代',
                desc: '屯田专著，系统规划立春后官田耕作流程'
            },
            '《农桑易知录》': {
                author: '郑之侨',
                era: '清代',
                desc: '岭南农书，提出立春观测蕉芽判断地温之法'
            },
            '《郡县农政》': {
                author: '包世臣',
                era: '清代',
                desc: '批注《月令》立春条，反思官府劝农仪式实效'
            },
            '《山居琐言》': {
                author: '王象晋',
                era: '明代',
                desc: '泰山农事笔记，记载立春观冰纹预测年成之术'
            }
        };
        class InteractiveBookCloud {
            constructor() {
                // 优化参数
                this.AUTO_ROTATION_SPEED = 0.006;  // 基础旋转速度
                this.autoRotationFactor = 1;
                this.SPHERE_RADIUS = 12;              // 增大球体半径
                this.ROTATION_SENSITIVITY = 0.002;   // 降低灵敏度
                this.BG_IMAGE_URL = './img/雨水.png';
                this.BG_OPACITY = 0.6;
                // 新增字体参数
                this.BASE_FONT_SIZE = 60;           // 基础字号
                this.FONT_PADDING = 40;              // 文字边距

                this.isDragging = false;
                this.rotateVelocity = new THREE.Vector2();
                this.initThree();
                this.createBackground(() => {
                    this.createCloud();
                    this.initEvents();
                    this.animate();
                });
            }

            initThree() {
                this.scene = new THREE.Scene();
                this.renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance",
                    // 增加抗锯齿参数
                    //multisampling: 8 // 启用多重采样
                });
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);

                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 0, 30);  // 拉远相机

                // 优化光照
                const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
                directionalLight.position.set(15, 20, 15);
                this.scene.add(ambientLight, directionalLight);
            }

            createBackground(callback) {
                const loader = new THREE.TextureLoader();
                loader.load(
                    this.BG_IMAGE_URL,
                    texture => {
                        console.log('背景图加载成功'); // 调试日志

                        // 修正材质设置
                        const bgGeometry = new THREE.SphereGeometry(100, 64, 64);
                        const bgMaterial = new THREE.MeshBasicMaterial({
                            map: texture,
                            side: THREE.BackSide,
                            transparent: true,
                            opacity: this.BG_OPACITY,
                            depthWrite: false // 关键修复：禁用深度写入
                        });

                        this.background = new THREE.Mesh(bgGeometry, bgMaterial);
                        this.scene.add(this.background);

                        // 确保背景在场景最底层
                        this.background.renderOrder = -1;

                        callback();
                    },
                    undefined,
                    err => {
                        console.error('背景图加载失败:', err);
                        // 应急方案：使用纯色背景
                        this.scene.background = new THREE.Color(0xE0E0E0);
                        callback();
                    }
                );
            }

            createCloud() {
                this.cloudGroup = new THREE.Group();
                const books = [
                    { name: '《农政全书》', size: 2.4 },
                    { name: '《齐民要术》', size: 2.3 },
                    { name: '《四民月令》', size: 2.2 },
                    { name: '《月令广义》', size: 2.1 },
                    { name: '《吕氏春秋·上农四篇》', size: 2.0 },
                    { name: '《授时通考》', size: 1.9 },
                    { name: '《氾胜之书》', size: 1.8 },
                    { name: '《王祯农书》', size: 1.7 },
                    { name: '《陈旉农书》', size: 1.6 },
                    { name: '《农桑辑要》', size: 1.5 },
                    { name: '《天工开物》', size: 1.4 },
                    { name: '《岁时广记》', size: 1.3 },
                    { name: '《淮南子·时则训》', size: 1.2 },
                    { name: '《礼记·月令》', size: 1.1 },
                    { name: '《沈氏农书》', size: 1.0 },
                    { name: '《三农纪》', size: 0.9 },
                    { name: '《农桑衣食撮要》', size: 0.8 },
                    { name: '《群芳谱》及《广群芳谱》', size: 0.7 },
                    { name: '《月令七十二候集解》', size: 0.6 },
                    { name: '《夏小正》', size: 0.5 },
                    { name: '《田家五行》', size: 1.8 },
                    { name: '《农候杂占》', size: 1.7 },
                    { name: '《农丹》', size: 1.6 },
                    { name: '《知本提纲·农则》', size: 1.5 },
                    { name: '《农圃便览》', size: 1.4 },
                    { name: '《马首农言》', size: 1.3 },
                    { name: '《营田辑要》', size: 1.2 },
                    { name: '《农桑易知录》', size: 1.1 },
                    { name: '《郡县农政》', size: 1.0 },
                    { name: '《山居琐言》', size: 0.9 }
                ];
                books.forEach((book, i) => {
                    const textMesh = this.createTextMesh(book.name, book.size);
                    const position = this.calculatePosition(i, books.length);
                    textMesh.position.copy(position);
                    textMesh.userData = bookDetails[book.name];
                    this.cloudGroup.add(textMesh);
                });

                this.scene.add(this.cloudGroup);
                document.getElementById('loading').remove();
            }

            createTextMesh(text, size) {
                // 提升分辨率处理
                const dpr = window.devicePixelRatio || 1;
                const targetScale = 2; // 额外提升2倍分辨率

                // 创建高清canvas
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                // 计算基础尺寸
                const baseFontSize = this.BASE_FONT_SIZE * size;
                const fontSize = baseFontSize * targetScale; // 提升后的实际字号

                // 设置字体（改为更清晰的字体）
                ctx.font = `600 ${fontSize}px 'Microsoft Yahei', 宋体`; // 600字重提升清晰度

                // 测量文本
                const metrics = ctx.measureText(text);
                const textWidth = metrics.width;
                const textHeight = fontSize * 1.2; // 留出行高空间

                // 设置canvas尺寸（高清处理）
                canvas.width = (textWidth + this.FONT_PADDING * 2) * dpr * targetScale;
                canvas.height = (textHeight + this.FONT_PADDING * 2) * dpr * targetScale;

                // 重置缩放比例
                ctx.scale(dpr * targetScale, dpr * targetScale);

                // 绘制文本
                ctx.fillStyle = '#2c5f2d';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.clearRect(0, 0, canvas.width / (dpr * targetScale), canvas.height / (dpr * targetScale));
                ctx.fillText(
                    text,
                    (canvas.width / (dpr * targetScale)) / 2,
                    (canvas.height / (dpr * targetScale)) / 2
                );

                // 创建纹理（增加锐化参数）
                const texture = new THREE.CanvasTexture(canvas);
                texture.anisotropy = 16;
                texture.minFilter = THREE.LinearFilter; // 禁用mipmap避免模糊
                texture.magFilter = THREE.LinearFilter;

                // 调整sprite尺寸计算
                const spriteSize = baseFontSize * 0.8; // 显示尺寸系数
                const aspect = canvas.width / canvas.height;
                const sprite = new THREE.Sprite(
                    new THREE.SpriteMaterial({
                        map: texture,
                        transparent: true,
                        opacity: 0.95
                    })
                );
                sprite.scale.set(
                    spriteSize * aspect * 0.5, // 尺寸补偿系数
                    spriteSize * 0.5,
                    1
                );

                return sprite;
            }

            calculatePosition(index, total) {
                const phi = Math.PI * (3 - Math.sqrt(5));
                const y = 1 - (index / total) * 2;
                const radius = Math.sqrt(1 - y * y) * this.SPHERE_RADIUS;
                const theta = phi * index;

                return new THREE.Vector3(
                    Math.cos(theta) * radius,
                    y * this.SPHERE_RADIUS * 0.7,
                    Math.sin(theta) * radius
                );
            }

            initEvents() {
                const dom = this.renderer.domElement;
                let lastX = 0, lastY = 0;
                let deltaX = 0, deltaY = 0;
                document.getElementById('homeBtn').addEventListener('click', () => {
                    window.location.href = '../1界面.html'; // 替换成你的主界面URL
                });

                dom.addEventListener('mousedown', e => {
                    this.isDragging = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                });

                dom.addEventListener('mousemove', e => {
                    if (!this.isDragging) return;

                    deltaX = e.clientX - lastX;
                    deltaY = e.clientY - lastY;
                    lastX = e.clientX;
                    lastY = e.clientY;

                    // 添加速度衰减
                    this.rotateVelocity.x = deltaX * this.ROTATION_SENSITIVITY * 0.8;
                    this.rotateVelocity.y = deltaY * this.ROTATION_SENSITIVITY * 0.8;

                    this.cloudGroup.rotation.y += this.rotateVelocity.x;
                    this.cloudGroup.rotation.x += this.rotateVelocity.y;
                });

                dom.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    // 添加惯性效果
                    this.rotateVelocity.multiplyScalar(0.95);
                });

                dom.addEventListener('click', e => this.handleClick(e));
                window.addEventListener('resize', () => this.handleResize());
            }

            handleClick(e) {
                const mouse = new THREE.Vector2(
                    (e.clientX / window.innerWidth) * 2 - 1,
                    -(e.clientY / window.innerHeight) * 2 + 1
                );

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);
                const intersects = raycaster.intersectObjects(this.cloudGroup.children);

                if (intersects.length > 0) {
                    this.showTooltip(intersects[0].object);
                }
            }

            showTooltip(object) {
                const tooltip = document.getElementById('tooltip');
                const vector = object.position.clone().project(this.camera);

                // 优化定位算法
                const x = Math.min(
                    Math.max(vector.x * 0.5 * window.innerWidth + window.innerWidth / 2 + 20, 20),
                    window.innerWidth - 340
                );
                const y = vector.y * -0.5 * window.innerHeight + window.innerHeight / 2;

                tooltip.style.transform = `translate(${x}px, ${y}px)`;
                tooltip.style.display = 'block';
                document.getElementById('tooltip-content').innerHTML = `
                    <h3>${object.name}</h3>
                    <p><strong>作者：</strong>${object.userData.author}</p>
                    <p><strong>年代：</strong>${object.userData.era}</p>
                    <p>${object.userData.desc}</p>
                `;
            }

            handleResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }


            animate() {
                requestAnimationFrame(() => this.animate());

                // 新增自动旋转逻辑
                if (!this.isDragging && this.rotateVelocity.length() < 0.001) {
                    this.cloudGroup.rotation.y += this.AUTO_ROTATION_SPEED * this.autoRotationFactor;
                    this.autoRotationFactor += Math.sin(Date.now() * 0.001) * 0.02;
                }

                // 原有惯性逻辑
                if (!this.isDragging && this.rotateVelocity.length() > 0.001) {
                    this.cloudGroup.rotation.y += this.rotateVelocity.x;
                    this.cloudGroup.rotation.x += this.rotateVelocity.y;
                    this.rotateVelocity.multiplyScalar(0.97);
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        function closeTooltip(event) {
            event.stopPropagation();
            document.getElementById('tooltip').style.display = 'none';
        }

        new InteractiveBookCloud();
    </script>
</body>

</html>